


TO DO:

- (Done) comparisons
- (Done) reducers: any, all
- (Done) Boolean masks (requires dtypes. would be only number and bool)
- (Done) logical operations
- (Done) numbers in -1.4e-3 notation
- (Done) isclose
- (Done) Concurrency: the variables are being replaced with a global variable
- (Done) First integration to D3JS inside the notebook
- (DONE) shortcut reduce of any and all and allclose
- (DONE) linspace and geomspace
- (DONE) sign, abs, exp, log, sin, cos, sinh, cosh, asin, asin, ...
- (DONE) Round
- (DONE) arguments
- (DONE) ellipsis in slices
- (DONE) Better support for kwargs using this 
- (DONE) npm and license
- (DONE) (can be improved) improve assignment: options have add(A,B, out=..., where=...) they have `__iadd__ = add(A, B, A) ` and define array views. I should do the same, but views take time, I think. They also say `.reshape() creates a view` and `advanced indexing creates a copy` and `It must be noted here that during the assignment of x[[1, 2]] = [[10, 11, 12], [13, 14, 15]], no view or copy is created as the assignment happens in-place.`. So, `y = x[[1, 2]]` creates a copy but `y = x[1:3]` creates a view. According to my experiments, "advanced indexing" occurs when the indexSpec contains boolean masks or integer indices. For fixed integer, range slices, ellipsis, 'None', and ':'.
- (DONE) List all the functions that access array.flat
- (DONE) compose simple indexes
- (DONE) Print in different format
- (DONE) Handle the or operator "|" properly: for booleans gives booleans. For numbers gives numbers. 
- (DONE) parser should not return to_list, should it?
- (DONE) Support for 128 bits dtype? (Nope. I don't use that much, and js does not support that natively)
- (DONE) make the module callable
- (DONE) provide two calls: if template string... otherwise, asarray np`...` np(...)
- (DONE) don't put everything into the array class. E.g., np.array.linspace makes no sense.
- (DONE) separate these as core: slice, _binary_operator, _assign_operator, _reduce, _apply, "_transform" (e.g. sort)
- (DONE) I can't find a "apply_pointwise" function. Instead they have "vectorize" for functions. call it apply_pointwise
- (DONE) enable GeneralIndexSpec to accept string '::-1' instead of already parsed range object.
- (DONE) fix the JSDoc signature of methods that replace this.
- (DONE) is there a way to copy the jsdoc of another function, but replacing the first argument? No.
- (DONE) np.sort
- (DONE) np.random.normal
- (DONE) implement "transform". Take into account that reduce is called "apply_along_axis" in numpy jargon, and it supports nd output, so it's my "transform"
- (DONE) implement transposition
- (DONE) decide a notation for slice and assignment
- (DONE) implement index notation
- (DONE) np.stack, np.concatenate
- (DONE) array iterator
- (DONE) np.random.shuffle, np.random."shuffled", 
- (DONE) Optimize with webpack


- purposeful readme, with plots and good examples



- Export map.js as well
- Add license to webpack

- implement vectorize
- np.where
- np.unique

- np.split
- np.cov
- np.hist
- np.bins

- group_by function

- all core functions should assume that the first input is already an array

- np.d3_snippets: examples



- add correct dtypes to operations

- make asarray global
- allow these syntax forms:  A.op('+', B) ;  A.op('+=', B) ; A.op('~') ; A.op(['::-1', 0], '+=', B)
- What about A([':', 0]), A('+', B([[false, true]])) // I like it. It's very succinct and clear.
- What about np(A, [':', 0], '+=', B, [[false, true]], '+') // NO. The reader has no clue of the precedence. 

- Download mozilla reference



- search for autogenerated docs options


- Get click to work in Guake

- What about np`statement; \n statement;\n ...;\n return blah, blah, blah`? Proposal: let {a, b, c} = np.block`${np.var('a')} = ...`});   Alternative: let {a, b, c} = np.block`VARS {a, b, c}; a = ...; b=...; b[:,a]=3; c = b.sum()`

- speed up tests by running several python tests at once. Maybe printing to file?


- add shortcut rules to operators, so that 0+x or 1*x or false||x returns x without iterating 


- maximum and minimum with ↑ and ↓. What priority wr to + *, ** and the logical operators?


- Write concurrency tests
- Random module
- Linalg module



